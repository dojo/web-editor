{"version":3,"file":"registerCustomElement.js","sourceRoot":"","sources":["registerCustomElement.ts"],"names":[],"mappings":";;;;;;;;;;;;IAAA,mDAK0B;IAgB1B;;;;;;OAMG;IACH,+BAAsC,iBAAiD;QACtF,IAAM,UAAU,GAAG,iBAAiB,EAAE,CAAC;QAEvC,cAAc,CAAC,MAAM,CAAC,UAAU,CAAC,OAAO;YAAgB,mCAAW;YAKlE;gBAAA,YACC,iBAAO,SAGP;gBARO,iBAAW,GAAG,KAAK,CAAC;gBAO3B,KAAI,CAAC,SAAS,GAAG,kCAAiB,CAAC,KAAI,CAAC,CAAC;;YAC1C,CAAC;YAEM,mCAAiB,GAAxB;gBACC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;oBACvB,IAAI,CAAC,SAAS,EAAE,CAAC;oBACjB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;oBACxB,IAAI,CAAC,aAAa,CAAC,IAAI,iCAAgB,CAAC,WAAW,EAAE;wBACpD,OAAO,EAAE,KAAK;qBACd,CAAC,CAAC,CAAC;gBACL,CAAC;YACF,CAAC;YAEM,0CAAwB,GAA/B,UAAgC,IAAY,EAAE,QAAuB,EAAE,QAAuB;gBAC7F,uCAAsB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACxD,CAAC;YAEM,mCAAiB,GAAxB;gBACC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;YAC7B,CAAC;YAEM,mCAAiB,GAAxB,UAAyB,MAA2B;gBACnD,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC;YAC/B,CAAC;YAEM,sCAAoB,GAA3B;gBACC,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC;YAC/C,CAAC;YAEM,+BAAa,GAApB;gBACC,MAAM,CAAC,UAAU,CAAC;YACnB,CAAC;YAED,sBAAW,6BAAkB;qBAA7B;oBACC,MAAM,CAAC,CAAC,UAAU,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,UAAA,SAAS,IAAI,OAAA,SAAS,CAAC,aAAa,EAAvB,CAAuB,CAAC,CAAC;gBAChF,CAAC;;;eAAA;YACF,cAAC;QAAD,CAAC,AA5CyC,CAAc,WAAW,GA4CjE,CAAC;IACJ,CAAC;IAhDD,sDAgDC;IAED,kBAAe,qBAAqB,CAAC","sourcesContent":["import {\n\tcustomEventClass,\n\tCustomElementDescriptor,\n\thandleAttributeChanged,\n\tinitializeElement\n} from './customElements';\nimport { Constructor, WidgetProperties } from './interfaces';\nimport { WidgetBase } from './WidgetBase';\nimport { ProjectorMixin } from './mixins/Projector';\n\ndeclare namespace customElements {\n\tfunction define(name: string, constructor: any): void;\n}\n\n/**\n * Describes a function that returns a CustomElementDescriptor\n */\nexport interface CustomElementDescriptorFactory {\n\t(): CustomElementDescriptor;\n}\n\n/**\n * Register a custom element using the v1 spec of custom elements. Note that\n * this is the default export, and, expects the proposal to work in the browser.\n * This will likely require the polyfill and native shim.\n *\n * @param descriptorFactory\n */\nexport function registerCustomElement(descriptorFactory: CustomElementDescriptorFactory) {\n\tconst descriptor = descriptorFactory();\n\n\tcustomElements.define(descriptor.tagName, class extends HTMLElement {\n\t\tprivate _isAppended = false;\n\t\tprivate _appender: Function;\n\t\tprivate _widgetInstance: ProjectorMixin<any>;\n\n\t\tconstructor() {\n\t\t\tsuper();\n\n\t\t\tthis._appender = initializeElement(this);\n\t\t}\n\n\t\tpublic connectedCallback() {\n\t\t\tif (!this._isAppended) {\n\t\t\t\tthis._appender();\n\t\t\t\tthis._isAppended = true;\n\t\t\t\tthis.dispatchEvent(new customEventClass('connected', {\n\t\t\t\t\tbubbles: false\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\n\t\tpublic attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {\n\t\t\thandleAttributeChanged(this, name, newValue, oldValue);\n\t\t}\n\n\t\tpublic getWidgetInstance(): ProjectorMixin<any> {\n\t\t\treturn this._widgetInstance;\n\t\t}\n\n\t\tpublic setWidgetInstance(widget: ProjectorMixin<any>): void {\n\t\t\tthis._widgetInstance = widget;\n\t\t}\n\n\t\tpublic getWidgetConstructor(): Constructor<WidgetBase<WidgetProperties>> {\n\t\t\treturn this.getDescriptor().widgetConstructor;\n\t\t}\n\n\t\tpublic getDescriptor(): CustomElementDescriptor {\n\t\t\treturn descriptor;\n\t\t}\n\n\t\tstatic get observedAttributes(): string[] {\n\t\t\treturn (descriptor.attributes || []).map(attribute => attribute.attributeName);\n\t\t}\n\t});\n}\n\nexport default registerCustomElement;\n"]}