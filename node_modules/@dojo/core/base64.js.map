{"version":3,"file":"base64.js","sourceRoot":"","sources":["base64.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,4CAAuC;IACvC,qCAAmD;IAEnD,SAAM,CAAC,MAAM,EAAE,MAAM,IAAI,gBAAM,EAAE,IAAI,CAAC,CAAC;IACvC,SAAM,CAAC,MAAM,EAAE,MAAM,IAAI,gBAAM,EAAE,IAAI,CAAC,CAAC;IAEvC;;;OAGG;IACU,QAAA,MAAM,GAAsC,aAAG,CAAC,MAAM,CAAC,GAAG,UAAU,aAAqB;QACrG,4DAA4D;QAC5D,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,UAAC,IAAY,IAAK,OAAA,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAxD,CAAwD,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/J,CAAC,GAAG,UAAU,aAAqB;QAClC,MAAM,CAAC,IAAI,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IACxE,CAAC,CAAC;IAEF;;;OAGG;IACU,QAAA,MAAM,GAAkC,aAAG,CAAC,MAAM,CAAC,GAAG,UAAU,aAAqB;QACjG,4DAA4D;QAC5D,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,iBAAiB,EAAE,UAAC,KAAK,EAAE,IAAY,IAAK,OAAA,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,EAAxC,CAAwC,CAAC,CAAC,CAAC;IAC9I,CAAC,GAAG,UAAU,SAAiB;QAC9B,MAAM,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IACpE,CAAC,CAAC","sourcesContent":["import global from '@dojo/shim/global';\nimport has, { add as hasAdd } from '@dojo/has/has';\n\nhasAdd('btoa', 'btoa' in global, true);\nhasAdd('atob', 'atob' in global, true);\n\n/**\n * Take a string encoded in base64 and decode it\n * @param encodedString The base64 encoded string\n */\nexport const decode: (encodedString: string) => string = has('atob') ? function (encodedString: string) {\n\t/* this allows for utf8 characters to be decoded properly */\n\treturn decodeURIComponent(Array.prototype.map.call(atob(encodedString), (char: string) => '%' + ('00' + char.charCodeAt(0).toString(16)).slice(-2)).join(''));\n} : function (encodedString: string): string {\n\treturn new Buffer(encodedString.toString(), 'base64').toString('utf8');\n};\n\n/**\n * Take a string and encode it to base64\n * @param rawString The string to encode\n */\nexport const encode: (rawString: string) => string = has('btoa') ? function (decodedString: string) {\n\t/* this allows for utf8 characters to be encoded properly */\n\treturn btoa(encodeURIComponent(decodedString).replace(/%([0-9A-F]{2})/g, (match, code: string) => String.fromCharCode(Number('0x' + code))));\n} : function (rawString: string): string {\n\treturn new Buffer(rawString.toString(), 'utf8').toString('base64');\n};\n"]}