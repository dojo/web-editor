{"version":3,"file":"QueuingEvented.js","sourceRoot":"","sources":["QueuingEvented.ts"],"names":[],"mappings":";;;;;;;;;;;;IACA,sCAAiC;IACjC,qCAA8D;IAE9D;;;;;;OAMG;IACH;QAA4C,0CAAO;QAMlD;YAAA,YACC,iBAAO,SAkBP;YArBD,eAAS,GAAG,CAAC,CAAC;YAKb,KAAI,CAAC,MAAM,GAAG,IAAI,aAAG,EAAyB,CAAC;YAC/C,KAAI,CAAC,WAAW,GAAG,KAAI,CAAC,EAAE,CAAC;YAC3B,KAAI,CAAC,EAAE,GAAG;gBAAA,iBAaT;gBAbyC,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,yBAAc;;gBACvD,IAAI,MAAM,GAAG,IAAI,CAAC,WAAW,OAAhB,IAAI,mBAAgB,IAAI,EAAC,CAAC;gBAEvC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,YAAY;oBAC9C,KAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,UAAU;wBACtC,EAAE,CAAC,CAAC,qBAAW,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC;4BAC3C,MAAM,CAAC,OAAO,CAAC,UAAC,KAAK,IAAK,OAAA,KAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAhB,CAAgB,CAAC,CAAC;4BAC5C,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;wBAChC,CAAC;oBACF,CAAC,CAAC,CAAC;gBACJ,CAAC,CAAC,CAAC;gBAEH,MAAM,CAAC,MAAM,CAAC;YACf,CAAC,CAAC;;QACH,CAAC;QAED,6BAAI,GAAJ,UAA4B,KAAQ;YACnC,iBAAM,IAAI,YAAC,KAAK,CAAC,CAAC;YAElB,IAAI,QAAQ,GAAG,KAAK,CAAC;YAErB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,IAAI;gBACtC,EAAE,CAAC,CAAC,qBAAW,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnC,QAAQ,GAAG,IAAI,CAAC;gBACjB,CAAC;YACF,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACf,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAExC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACZ,KAAK,GAAG,EAAE,CAAC;oBACX,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBACpC,CAAC;gBAED,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAElB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;oBACxB,OAAO,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;wBACtC,KAAK,CAAC,KAAK,EAAE,CAAC;oBACf,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC;QACF,qBAAC;IAAD,CAAC,AAvDD,CAA4C,iBAAO,GAuDlD","sourcesContent":["import { Handle } from '@dojo/interfaces/core';\nimport Map from '@dojo/shim/Map';\nimport Evented, { isGlobMatch, EventObject } from './Evented';\n\n/**\n * An implementation of the Evented class that queues up events when no listeners are\n * listening. When a listener is subscribed, the queue will be published to the listener.\n * When the queue is full, the oldest events will be discarded to make room for the newest ones.\n *\n * @property maxEvents  The number of events to queue before old events are discarded. If zero (default), an unlimited number of events is queued.\n */\nexport default class QueuingEvented extends Evented {\n\tprivate _queue: Map<string | symbol, EventObject[]>;\n\tprivate _originalOn: (...args: any[]) => Handle;\n\n\tmaxEvents = 0;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._queue = new Map<string, EventObject[]>();\n\t\tthis._originalOn = this.on;\n\t\tthis.on = function (this: QueuingEvented, ...args: any[]): Handle {\n\t\t\tlet handle = this._originalOn(...args);\n\n\t\t\tthis.listenersMap.forEach((method, listenerType) => {\n\t\t\t\tthis._queue.forEach((events, queuedType) => {\n\t\t\t\t\tif (isGlobMatch(listenerType, queuedType)) {\n\t\t\t\t\t\tevents.forEach((event) => this.emit(event));\n\t\t\t\t\t\tthis._queue.delete(queuedType);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn handle;\n\t\t};\n\t}\n\n\temit<E extends EventObject>(event: E): void {\n\t\tsuper.emit(event);\n\n\t\tlet hasMatch = false;\n\n\t\tthis.listenersMap.forEach((method, type) => {\n\t\t\tif (isGlobMatch(type, event.type)) {\n\t\t\t\thasMatch = true;\n\t\t\t}\n\t\t});\n\n\t\tif (!hasMatch) {\n\t\t\tlet queue = this._queue.get(event.type);\n\n\t\t\tif (!queue) {\n\t\t\t\tqueue = [];\n\t\t\t\tthis._queue.set(event.type, queue);\n\t\t\t}\n\n\t\t\tqueue.push(event);\n\n\t\t\tif (this.maxEvents > 0) {\n\t\t\t\twhile (queue.length > this.maxEvents) {\n\t\t\t\t\tqueue.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}