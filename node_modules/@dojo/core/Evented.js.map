{"version":3,"file":"Evented.js","sourceRoot":"","sources":["Evented.ts"],"names":[],"mappings":"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","sourcesContent":["import { Actionable } from '@dojo/interfaces/abilities';\nimport { EventedListener, EventedListenerOrArray, EventedListenersMap } from '@dojo/interfaces/bases';\nimport { EventTargettedObject, EventErrorObject, Handle } from '@dojo/interfaces/core';\nimport Map from '@dojo/shim/Map';\nimport { on as aspectOn } from './aspect';\nimport { Destroyable } from './Destroyable';\n\n/**\n * Determines is the value is Actionable (has a `.do` function)\n *\n * @param value the value to check\n * @returns boolean indicating is the value is Actionable\n */\nfunction isActionable(value: any): value is Actionable<any, any> {\n\treturn Boolean(value && typeof value.do === 'function');\n}\n\n/**\n * Resolve listeners.\n */\nfunction resolveListener<T, E extends EventTargettedObject<T>>(listener: EventedListener<T, E>): EventedCallback<E> {\n\treturn isActionable(listener) ? (event: E) => listener.do({ event }) : listener;\n}\n\n/**\n * Handles an array of handles\n *\n * @param handles an array of handles\n * @returns a single Handle for handles passed\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\n/**\n * The base event object, which provides a `type` property\n */\nexport interface EventObject {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: string | symbol;\n}\n\nexport interface EventedCallback<E extends EventObject> {\n\t/**\n\t * A callback that takes an `event` argument\n\t *\n\t * @param event The event object\n\t */\n\t(event: E): boolean | void;\n}\n\n/**\n * Interface for Evented constructor options\n */\nexport interface EventedOptions {\n\t/**\n\t * Optional listeners to add\n\t */\n\tlisteners?: EventedListenersMap<any>;\n}\n\nexport interface BaseEventedEvents {\n\t/**\n\t * Regsister a callback for a specific event type\n\t *\n\t * @param listeners map of listeners\n\t */\n\t(listeners: EventedListenersMap<Evented>): Handle;\n\n\t/**\n\t * @param type the type of the event\n\t * @param listener the listener to attach\n\t */\n\t(type: string | symbol, listener: EventedListenerOrArray<Evented, EventTargettedObject<Evented>>): Handle;\n\n\t/**\n\t * @param type the type for `error`\n\t * @param listener the listener to attach\n\t */\n\t(type: 'error', listener: EventedListenerOrArray<Evented, EventErrorObject<Evented>>): Handle;\n}\n\nexport interface Evented {\n\ton: BaseEventedEvents;\n}\n\n/**\n * Map of computed regular expressions, keyed by string\n */\nconst regexMap = new Map<string, RegExp>();\n\n/**\n * Determines is the event type glob has been matched\n *\n * @returns boolean that indicates if the glob is matched\n */\nexport function isGlobMatch(globString: string | symbol, targetString: string | symbol): boolean {\n\tif (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {\n\t\tlet regex: RegExp;\n\t\tif (regexMap.has(globString)) {\n\t\t\tregex = regexMap.get(globString)!;\n\t\t}\n\t\telse {\n\t\t\tregex = new RegExp(`^${ globString.replace(/\\*/g, '.*') }$`);\n\t\t\tregexMap.set(globString, regex);\n\t\t}\n\t\treturn regex.test(targetString);\n\n\t} else {\n\t\treturn globString === targetString;\n\t}\n}\n\n/**\n * Event Class\n */\nexport class Evented extends Destroyable implements Evented {\n\n\t/**\n\t * map of listeners keyed by event type\n\t */\n\tprotected listenersMap: Map<string, EventedCallback<EventObject>> = new Map<string, EventedCallback<EventObject>>();\n\n\t/**\n\t * @constructor\n\t * @param options The constructor argurments\n\t */\n\tconstructor(options: EventedOptions = {}) {\n\t\tsuper();\n\t\tconst { listeners } = options;\n\t\tif (listeners) {\n\t\t\tthis.own(this.on(listeners));\n\t\t}\n\t}\n\n\t/**\n\t * Emits the event objet for the specified type\n\t *\n\t * @param event the event to emit\n\t */\n\temit<E extends EventObject>(event: E): void {\n\t\tthis.listenersMap.forEach((method, type) => {\n\t\t\tif (isGlobMatch(type, event.type)) {\n\t\t\t\tmethod.call(this, event);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Catch all handler for various call signatures. The signatures are defined in\n\t * `BaseEventedEvents`.  You can add your own event type -> handler types by extending\n\t * `BaseEventedEvents`.  See example for details.\n\t *\n\t * @param args\n\t *\n\t * @example\n\t *\n\t * interface WidgetBaseEvents extends BaseEventedEvents {\n\t *     (type: 'properties:changed', handler: PropertiesChangedHandler): Handle;\n\t * }\n\t * class WidgetBase extends Evented {\n\t *    on: WidgetBaseEvents;\n\t * }\n\t *\n\t * @return {any}\n\t */\n\ton: BaseEventedEvents = function (this: Evented, ...args: any[]) {\n\t\tif (args.length === 2) {\n\t\t\tconst [ type, listeners ] = <[ string, EventedListenerOrArray<any, EventTargettedObject<any>>]> args;\n\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\tconst handles = listeners.map((listener) => aspectOn(this.listenersMap, type, resolveListener(listener)));\n\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn aspectOn(this.listenersMap, type, resolveListener(listeners));\n\t\t\t}\n\t\t}\n\t\telse if (args.length === 1) {\n\t\t\tconst [ listenerMapArg ] = <[EventedListenersMap<any>]> args;\n\t\t\tconst handles = Object.keys(listenerMapArg).map((type) => this.on(type, listenerMapArg[type]));\n\t\t\treturn handlesArraytoHandle(handles);\n\t\t}\n\t\telse {\n\t\t\tthrow new TypeError('Invalid arguments');\n\t\t}\n\t};\n}\n\nexport default Evented;\n"]}