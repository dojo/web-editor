{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA;;;;;;;;OAQG;IACH,4BAAsC,KAAQ,EAAE,UAA2B,EAAE,QAAwB,EAAE,YAA4B;QAAnF,2BAAA,EAAA,kBAA2B;QAAE,yBAAA,EAAA,eAAwB;QAAE,6BAAA,EAAA,mBAA4B;QAClI,MAAM,CAAC;YACN,KAAK,EAAE,KAAK;YACZ,UAAU,EAAE,UAAU;YACtB,QAAQ,EAAE,QAAQ;YAClB,YAAY,EAAE,YAAY;SAC1B,CAAC;IACH,CAAC;IAPD,gDAOC;IAaD,oBAA2B,cAAuC;QACjE,MAAM,CAAC,UAAU,MAAW;YAAE,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,6BAAc;;YAC3C,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC3C,CAAC,CAAC;IACH,CAAC;IAJD,gCAIC","sourcesContent":["/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nexport function getValueDescriptor<T>(value: T, enumerable: boolean = false, writable: boolean = true, configurable: boolean = true): TypedPropertyDescriptor<T> {\n\treturn {\n\t\tvalue: value,\n\t\tenumerable: enumerable,\n\t\twritable: writable,\n\t\tconfigurable: configurable\n\t};\n}\n\n/**\n * A helper function which wraps a function where the first argument becomes the scope\n * of the call\n *\n * @param nativeFunction The source function to be wrapped\n */\nexport function wrapNative<T, U, R>(nativeFunction: (arg1: U) => R): (target: T, arg1: U) => R;\nexport function wrapNative<T, U, V, R>(nativeFunction: (arg1: U, arg2: V) => R): (target: T, arg1: U, arg2: V) => R;\nexport function wrapNative<T, U, V, W, R>(nativeFunction: (arg1: U, arg2: V, arg3: W) => R): (target: T, arg1: U, arg2: V, arg3: W) => R;\nexport function wrapNative<T, U, V, W, X, R>(nativeFunction: (arg1: U, arg2: V, arg3: W) => R): (target: T, arg1: U, arg2: V, arg3: W) => R;\nexport function wrapNative<T, U, V, W, X, Y, R>(nativeFunction: (arg1: U, arg2: V, arg3: W, arg4: Y) => R): (target: T, arg1: U, arg2: V, arg3: W, arg4: Y) => R;\nexport function wrapNative(nativeFunction: (...args: any[]) => any): (target: any, ...args: any[]) => any {\n\treturn function (target: any, ...args: any[]): any {\n\t\treturn nativeFunction.apply(target, args);\n\t};\n}\n"]}