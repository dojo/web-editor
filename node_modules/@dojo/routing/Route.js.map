{"version":3,"file":"Route.js","sourceRoot":"","sources":["Route.ts"],"names":[],"mappings":"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","sourcesContent":["import UrlSearchParams from '@dojo/core/UrlSearchParams';\nimport { Thenable } from '@dojo/shim/interfaces';\nimport WeakMap from '@dojo/shim/WeakMap';\nimport {\n\tContext,\n\tDefaultParameters,\n\tHandler,\n\tLinkParams,\n\tMatchResult,\n\tMatchType,\n\tParameters,\n\tRequest,\n\tRouteInterface,\n\tSearchParams,\n\tSelection\n} from './interfaces';\nimport { deconstruct as deconstructPath, DeconstructedPath, match as matchPath } from './lib/path';\nimport { findRouter, hasBeenAppended } from './lib/router';\n\n/**\n * The options for the route.\n */\nexport interface RouteOptions<C, P extends Parameters> {\n\t/**\n\t * Path the route matches against. Pathname segments may be named, same for query parameters. Leading slashes are\n\t * ignored. Defaults to `/`.\n\t */\n\tpath?: string;\n\n\t/**\n\t * The outlet associated with the path\n\t */\n\toutlet?: string;\n\n\t/**\n\t * If the `path` option contains a trailing slash (in the pathname component), the route will only match against\n\t * another pathname that contains a trailing slash, and vice-versa if the path does not contain a trailing slash.\n\t * Defaults to `true`, change to `false` to allow routes to match regardless of trailing slashes.\n\t */\n\ttrailingSlashMustMatch?: boolean;\n\n\t/**\n\t * A handler called when the route is executed.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\texec?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * If specified, causes the route to be selected if there are no nested routes that match the remainder of\n\t * the dispatched path. When the route is executed, this handler is called rather than `exec()`.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\tfallback?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * Callback used to determine whether the route should be selected after it's been matched.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t * @return Returning `true` causes the route to be selected. Returning a string indicates that a redirect is\n\t *   required; the string should be the path to redirect to.\n\t */\n\tguard?(request: Request<C, P>): string | boolean;\n\n\t/**\n\t * If specified, and the route is the final route in the hierarchy, when the route is executed, this handler is\n\t * called rather than `exec()`.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\tindex?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * Callback used for constructing the `params` object from extracted parameters, and validating the parameters.\n\t * @param fromPathname Array of parameter values extracted from the pathname.\n\t * @param searchParams Parameters extracted from the search component.\n\t * @return If `null` prevents the route from being selected, else the value for the `params` object.\n\t */\n\tparams?(fromPathname: string[], searchParams: UrlSearchParams): null | P;\n\n\t/**\n\t * Default params to use when generating a link.\n\t */\n\tdefaultParams?: null | P;\n}\n\n// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n// change the private state of their children.\nconst parentMap = new WeakMap<Route<Context, Parameters>, Route<Context, Parameters>>();\n\nconst noop = () => {\n};\n\nfunction computeDefaultParams(parameters: string[], searchParameters: string[], fromPathname: string[], searchParams: UrlSearchParams): null | DefaultParameters {\n\tconst params: DefaultParameters = {};\n\tparameters.forEach((name, index) => {\n\t\tparams[ name ] = fromPathname[ index ];\n\t});\n\tsearchParameters.forEach(name => {\n\t\tconst value = searchParams.get(name);\n\t\tif (value !== undefined) {\n\t\t\tparams[ name ] = value;\n\t\t}\n\t});\n\n\treturn params;\n}\n\nexport class Route<C extends Context, P extends Parameters> implements RouteInterface<C, P> {\n\tprivate _path: DeconstructedPath;\n\tprivate _outlet: string | undefined;\n\tprivate _routes: Route<Context, Parameters>[];\n\tprivate _trailingSlashMustMatch: boolean;\n\tprivate _computeParams: (fromPathname: string[], searchParams: UrlSearchParams) => null | P | DefaultParameters;\n\tprivate _exec?: Handler;\n\tprivate _fallback?: Handler;\n\tprivate _guard: ((request: Request<C, P | DefaultParameters>) => string | boolean) | undefined;\n\tprivate _index?: Handler;\n\tprivate _defaultParams: P;\n\n\tget parent() {\n\t\treturn parentMap.get(this);\n\t}\n\n\tget path(this: Route<C, P>) {\n\t\treturn this._path;\n\t}\n\n\tget outlet() {\n\t\treturn this._outlet;\n\t}\n\n\tget defaultParams(): P {\n\t\treturn this._defaultParams;\n\t}\n\n\tconstructor(options: RouteOptions<C, P> = {}) {\n\t\tconst { exec, fallback, guard, index, params: computeParams, path, outlet, trailingSlashMustMatch = true, defaultParams = {} } = options;\n\n\t\tif (path && /#/.test(path)) {\n\t\t\tthrow new TypeError('Path must not contain \\'#\\'');\n\t\t}\n\n\t\tconst deconstructedPath = deconstructPath(path || '/');\n\t\tconst { parameters, searchParameters } = deconstructedPath;\n\n\t\tif (computeParams) {\n\t\t\tif (parameters.length === 0 && searchParameters.length === 0) {\n\t\t\t\tthrow new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n\t\t\t}\n\n\t\t\tthis._computeParams = computeParams;\n\t\t}\n\t\telse {\n\t\t\tthis._computeParams = (fromPathname: string[], searchParams: UrlSearchParams) => {\n\t\t\t\treturn computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n\t\t\t};\n\t\t}\n\n\t\tthis._exec = exec;\n\t\tthis._fallback = fallback;\n\t\tthis._guard = guard;\n\t\tthis._index = index;\n\t\tthis._path = deconstructedPath;\n\t\tthis._outlet = outlet;\n\t\tthis._routes = [];\n\t\tthis._defaultParams = <P> defaultParams;\n\t\tthis._trailingSlashMustMatch = trailingSlashMustMatch;\n\t}\n\n\tappend(add: Route<Context, Parameters> | Route<Context, Parameters>[]) {\n\t\tconst append = (route: Route<Context, Parameters>) => {\n\t\t\tif (hasBeenAppended(route)) {\n\t\t\t\tthrow new Error('Cannot append route that has already been appended');\n\t\t\t}\n\n\t\t\tthis._routes.push(route);\n\t\t\tparentMap.set(route, this);\n\t\t};\n\n\t\tif (Array.isArray(add)) {\n\t\t\tfor (const route of add) {\n\t\t\t\tappend(route);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tappend(add);\n\t\t}\n\t}\n\n\tlink(params?: LinkParams): string {\n\t\treturn findRouter(this).link(this, params);\n\t}\n\n\tmatch(segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): null | MatchResult<DefaultParameters | P> {\n\t\tconst result = matchPath(this._path, segments);\n\t\tif (result === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!result.hasRemaining && this._trailingSlashMustMatch && this._path.trailingSlash !== hasTrailingSlash) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Only extract the search params defined in the route's path.\n\t\tconst knownSearchParams = this._path.searchParameters.reduce<SearchParams>((list, name) => {\n\t\t\tconst value = searchParams.getAll(name);\n\t\t\tif (value !== undefined) {\n\t\t\t\tlist[ name ] = value;\n\t\t\t}\n\t\t\treturn list;\n\t\t}, {});\n\n\t\tconst params = this._computeParams(result.values, new UrlSearchParams(knownSearchParams));\n\t\tif (params === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\thasRemaining: result.hasRemaining,\n\t\t\toffset: result.offset,\n\t\t\tparams,\n\t\t\trawPathValues: result.values,\n\t\t\trawSearchParams: knownSearchParams\n\t\t};\n\t}\n\n\tselect(context: C, segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): string | Selection[] {\n\t\tconst matchResult = this.match(segments, hasTrailingSlash, searchParams);\n\n\t\t// Return early if possible.\n\t\tif (!matchResult || matchResult.hasRemaining && this._routes.length === 0 && !this._fallback && !this._outlet) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst { params } = matchResult;\n\t\tif (this._guard) {\n\t\t\tconst guardResult = this._guard({ context, params });\n\t\t\tif (typeof guardResult === 'string') {\n\t\t\t\treturn guardResult;\n\t\t\t}\n\t\t\tif (!guardResult) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\tlet handler = this._exec;\n\t\tlet type: MatchType = MatchType.PARTIAL;\n\t\tlet redirect: string | undefined;\n\t\tlet remainingSelection: Selection[] | undefined;\n\t\tlet selected = false;\n\n\t\tif (matchResult.hasRemaining) {\n\t\t\t// Match the remaining segments. Return a hierarchy if nested routes were selected.\n\t\t\tconst remainingSegments = segments.slice(matchResult.offset);\n\t\t\tselected = this._routes.some((nested) => {\n\t\t\t\tconst nestedResult = nested.select(context, remainingSegments, hasTrailingSlash, searchParams);\n\t\t\t\tif (typeof nestedResult === 'string') {\n\t\t\t\t\tredirect = nestedResult;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (nestedResult.length > 0) {\n\t\t\t\t\tremainingSelection = nestedResult;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\t// No remaining segments matched, only select this route if a fallback handler was specified.\n\t\t\tif (!selected && (this._outlet || this._fallback)) {\n\t\t\t\ttype = MatchType.ERROR;\n\t\t\t\tselected = true;\n\t\t\t\thandler = this._fallback || noop;\n\t\t\t}\n\t\t}\n\t\t// Select this route, configure the index handler if specified.\n\t\telse {\n\t\t\tselected = true;\n\t\t\ttype = MatchType.INDEX;\n\t\t\tif (this._index) {\n\t\t\t\thandler = this._index;\n\t\t\t}\n\t\t}\n\n\t\tif (!selected) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (redirect !== undefined) {\n\t\t\treturn redirect;\n\t\t}\n\n\t\tconst { rawPathValues, rawSearchParams } = matchResult;\n\t\tconst selection = {\n\t\t\t// Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n\t\t\t// think no routes were selected.\n\t\t\thandler: handler || noop,\n\t\t\tpath: this.path,\n\t\t\toutlet: this.outlet,\n\t\t\tparams,\n\t\t\trawPathValues,\n\t\t\trawSearchParams,\n\t\t\troute: this,\n\t\t\ttype\n\t\t};\n\t\treturn remainingSelection ? [ selection, ...remainingSelection ] : [ selection ];\n\t}\n}\n\nexport default Route;\n"]}