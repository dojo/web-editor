(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "@dojo/core/UrlSearchParams", "@dojo/shim/WeakMap", "./interfaces", "./lib/path", "./lib/router"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var UrlSearchParams_1 = require("@dojo/core/UrlSearchParams");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var interfaces_1 = require("./interfaces");
    var path_1 = require("./lib/path");
    var router_1 = require("./lib/router");
    // Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't
    // change the private state of their children.
    var parentMap = new WeakMap_1.default();
    var noop = function () {
    };
    function computeDefaultParams(parameters, searchParameters, fromPathname, searchParams) {
        var params = {};
        parameters.forEach(function (name, index) {
            params[name] = fromPathname[index];
        });
        searchParameters.forEach(function (name) {
            var value = searchParams.get(name);
            if (value !== undefined) {
                params[name] = value;
            }
        });
        return params;
    }
    var Route = /** @class */ (function () {
        function Route(options) {
            if (options === void 0) { options = {}; }
            var exec = options.exec, fallback = options.fallback, guard = options.guard, index = options.index, computeParams = options.params, path = options.path, outlet = options.outlet, _a = options.trailingSlashMustMatch, trailingSlashMustMatch = _a === void 0 ? true : _a, _b = options.defaultParams, defaultParams = _b === void 0 ? {} : _b;
            if (path && /#/.test(path)) {
                throw new TypeError('Path must not contain \'#\'');
            }
            var deconstructedPath = path_1.deconstruct(path || '/');
            var parameters = deconstructedPath.parameters, searchParameters = deconstructedPath.searchParameters;
            if (computeParams) {
                if (parameters.length === 0 && searchParameters.length === 0) {
                    throw new TypeError('Can\'t specify params() if path doesn\'t contain any');
                }
                this._computeParams = computeParams;
            }
            else {
                this._computeParams = function (fromPathname, searchParams) {
                    return computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);
                };
            }
            this._exec = exec;
            this._fallback = fallback;
            this._guard = guard;
            this._index = index;
            this._path = deconstructedPath;
            this._outlet = outlet;
            this._routes = [];
            this._defaultParams = defaultParams;
            this._trailingSlashMustMatch = trailingSlashMustMatch;
        }
        Object.defineProperty(Route.prototype, "parent", {
            get: function () {
                return parentMap.get(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Route.prototype, "path", {
            get: function () {
                return this._path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Route.prototype, "outlet", {
            get: function () {
                return this._outlet;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Route.prototype, "defaultParams", {
            get: function () {
                return this._defaultParams;
            },
            enumerable: true,
            configurable: true
        });
        Route.prototype.append = function (add) {
            var _this = this;
            var append = function (route) {
                if (router_1.hasBeenAppended(route)) {
                    throw new Error('Cannot append route that has already been appended');
                }
                _this._routes.push(route);
                parentMap.set(route, _this);
            };
            if (Array.isArray(add)) {
                try {
                    for (var add_1 = tslib_1.__values(add), add_1_1 = add_1.next(); !add_1_1.done; add_1_1 = add_1.next()) {
                        var route = add_1_1.value;
                        append(route);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (add_1_1 && !add_1_1.done && (_a = add_1.return)) _a.call(add_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                append(add);
            }
            var e_1, _a;
        };
        Route.prototype.link = function (params) {
            return router_1.findRouter(this).link(this, params);
        };
        Route.prototype.match = function (segments, hasTrailingSlash, searchParams) {
            var result = path_1.match(this._path, segments);
            if (result === null) {
                return null;
            }
            if (!result.hasRemaining && this._trailingSlashMustMatch && this._path.trailingSlash !== hasTrailingSlash) {
                return null;
            }
            // Only extract the search params defined in the route's path.
            var knownSearchParams = this._path.searchParameters.reduce(function (list, name) {
                var value = searchParams.getAll(name);
                if (value !== undefined) {
                    list[name] = value;
                }
                return list;
            }, {});
            var params = this._computeParams(result.values, new UrlSearchParams_1.default(knownSearchParams));
            if (params === null) {
                return null;
            }
            return {
                hasRemaining: result.hasRemaining,
                offset: result.offset,
                params: params,
                rawPathValues: result.values,
                rawSearchParams: knownSearchParams
            };
        };
        Route.prototype.select = function (context, segments, hasTrailingSlash, searchParams) {
            var matchResult = this.match(segments, hasTrailingSlash, searchParams);
            // Return early if possible.
            if (!matchResult || matchResult.hasRemaining && this._routes.length === 0 && !this._fallback && !this._outlet) {
                return [];
            }
            var params = matchResult.params;
            if (this._guard) {
                var guardResult = this._guard({ context: context, params: params });
                if (typeof guardResult === 'string') {
                    return guardResult;
                }
                if (!guardResult) {
                    return [];
                }
            }
            var handler = this._exec;
            var type = interfaces_1.MatchType.PARTIAL;
            var redirect;
            var remainingSelection;
            var selected = false;
            if (matchResult.hasRemaining) {
                // Match the remaining segments. Return a hierarchy if nested routes were selected.
                var remainingSegments_1 = segments.slice(matchResult.offset);
                selected = this._routes.some(function (nested) {
                    var nestedResult = nested.select(context, remainingSegments_1, hasTrailingSlash, searchParams);
                    if (typeof nestedResult === 'string') {
                        redirect = nestedResult;
                        return true;
                    }
                    if (nestedResult.length > 0) {
                        remainingSelection = nestedResult;
                        return true;
                    }
                    return false;
                });
                // No remaining segments matched, only select this route if a fallback handler was specified.
                if (!selected && (this._outlet || this._fallback)) {
                    type = interfaces_1.MatchType.ERROR;
                    selected = true;
                    handler = this._fallback || noop;
                }
            }
            else {
                selected = true;
                type = interfaces_1.MatchType.INDEX;
                if (this._index) {
                    handler = this._index;
                }
            }
            if (!selected) {
                return [];
            }
            if (redirect !== undefined) {
                return redirect;
            }
            var rawPathValues = matchResult.rawPathValues, rawSearchParams = matchResult.rawSearchParams;
            var selection = {
                // Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may
                // think no routes were selected.
                handler: handler || noop,
                path: this.path,
                outlet: this.outlet,
                params: params,
                rawPathValues: rawPathValues,
                rawSearchParams: rawSearchParams,
                route: this,
                type: type
            };
            return remainingSelection ? tslib_1.__spread([selection], remainingSelection) : [selection];
        };
        return Route;
    }());
    exports.Route = Route;
    exports.default = Route;
});
//# sourceMappingURL=Route.js.map