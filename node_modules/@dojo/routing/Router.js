(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "@dojo/core/async/Task", "@dojo/core/Evented", "@dojo/shim/object", "@dojo/core/on", "@dojo/core/UrlSearchParams", "@dojo/shim/array", "@dojo/shim/Map", "@dojo/shim/Promise", "./interfaces", "./lib/path", "./lib/router", "./Route"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var Task_1 = require("@dojo/core/async/Task");
    var Evented_1 = require("@dojo/core/Evented");
    var object_1 = require("@dojo/shim/object");
    var on_1 = require("@dojo/core/on");
    var UrlSearchParams_1 = require("@dojo/core/UrlSearchParams");
    var array_1 = require("@dojo/shim/array");
    var Map_1 = require("@dojo/shim/Map");
    var Promise_1 = require("@dojo/shim/Promise");
    var interfaces_1 = require("./interfaces");
    var path_1 = require("./lib/path");
    var router_1 = require("./lib/router");
    var Route_1 = require("./Route");
    exports.errorOutlet = 'errorOutlet';
    // istanbul ignore next
    var noop = function () {
    };
    function createDeferral() {
        // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.
        var cancel = noop;
        var resume = noop;
        var promise = new Promise_1.default(function (resolve, reject) {
            cancel = reject;
            // Wrap resolve to avoid resume being called with a thenable if type checking is not used.
            resume = function () { return resolve(); };
        });
        return { cancel: cancel, promise: promise, resume: resume };
    }
    function reportError(router, context, path, error) {
        router.emit({
            context: context,
            error: error,
            path: path,
            target: router,
            type: 'error'
        });
    }
    function catchRejection(router, context, path, thenable) {
        if (thenable) {
            Promise_1.default.resolve(thenable).catch(function (error) {
                reportError(router, context, path, error);
            });
        }
    }
    var Router = /** @class */ (function (_super) {
        tslib_1.__extends(Router, _super);
        function Router(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, {}) || this;
            _this._outletContextMap = new Map_1.default();
            _this._outletRouteMap = new Map_1.default();
            _this._currentParams = {};
            _this._defaultParams = {};
            var context = options.context, fallback = options.fallback, history = options.history, config = options.config;
            var contextFactory;
            if (typeof context === 'function') {
                contextFactory = context;
            }
            else if (typeof context === 'undefined') {
                contextFactory = function () {
                    return {};
                };
            }
            else {
                // Assign to a constant since the context variable may be changed after the function is defined,
                // which would violate its typing.
                var sharedContext_1 = context;
                contextFactory = function () { return sharedContext_1; };
            }
            if (history) {
                _this.own(history);
            }
            _this._contextFactory = contextFactory;
            _this._currentSelection = [];
            _this._dispatchFromStart = false;
            _this._fallback = fallback;
            _this._history = history;
            _this._routes = [];
            _this._started = false;
            if (config) {
                _this.register(config);
            }
            return _this;
        }
        Router.prototype.register = function (config, from) {
            var _this = this;
            if (from === void 0) { from = this; }
            var parent;
            if (typeof from === 'string') {
                parent = this._outletRouteMap.get(from) || this;
            }
            else {
                parent = from;
            }
            config.forEach(function (_a) {
                var defaultRoute = _a.defaultRoute, path = _a.path, _b = _a.outlet, outlet = _b === void 0 ? path : _b, _c = _a.defaultParams, defaultParams = _c === void 0 ? {} : _c, children = _a.children;
                var route = new Route_1.Route({
                    path: path,
                    outlet: outlet,
                    defaultParams: defaultParams
                });
                if (defaultRoute) {
                    if (!_this._defaultRoute) {
                        _this._defaultRoute = route;
                    }
                    else {
                        throw new Error("Default outlet has already been configured. Unable to register outlet " + outlet + " as the default.");
                    }
                }
                object_1.assign(_this._defaultParams, defaultParams);
                _this._outletRouteMap.set(outlet, route);
                parent.append(route);
                if (children) {
                    _this.register(children, route);
                }
            });
        };
        Router.prototype.append = function (add) {
            var _this = this;
            var append = function (route) {
                if (router_1.hasBeenAppended(route)) {
                    throw new Error('Cannot append route that has already been appended');
                }
                _this._routes.push(route);
                router_1.parentMap.set(route, _this);
            };
            if (Array.isArray(add)) {
                try {
                    for (var add_1 = tslib_1.__values(add), add_1_1 = add_1.next(); !add_1_1.done; add_1_1 = add_1.next()) {
                        var route = add_1_1.value;
                        append(route);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (add_1_1 && !add_1_1.done && (_a = add_1.return)) _a.call(add_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                append(add);
            }
            var e_1, _a;
        };
        Router.prototype._dispatch = function (context, path, canceled, emit) {
            var _this = this;
            if (canceled === void 0) { canceled = false; }
            if (emit === void 0) { emit = true; }
            if (canceled) {
                return { success: false };
            }
            this._currentParams = {};
            this._outletContextMap.clear();
            if (emit) {
                this.emit({
                    context: context,
                    path: path,
                    target: this,
                    type: 'navstart'
                });
            }
            var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;
            var dispatchFromStart = this._dispatchFromStart;
            this._dispatchFromStart = false;
            var redirect;
            var dispatched = this._routes.some(function (route) {
                var result = route.select(context, segments, trailingSlash, searchParams);
                if (typeof result === 'string') {
                    redirect = result;
                    return true;
                }
                if (result.length === 0) {
                    return false;
                }
                // Update the selected routes after selecting new routes, but before invoking the handlers.
                // This means the original value is available to guard() and params() functions, and the
                // new value when the newly selected routes are executed.
                //
                // Reset selected routes if not dispatched from start().
                _this._currentSelection = dispatchFromStart ? result : [];
                try {
                    for (var result_1 = tslib_1.__values(result), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {
                        var _a = result_1_1.value, handler = _a.handler, params = _a.params, outlet = _a.outlet, type = _a.type, route_1 = _a.route;
                        if (outlet) {
                            object_1.assign(_this._currentParams, params);
                            var location_1 = _this.link(route_1, _this._currentParams);
                            _this._outletContextMap.set(outlet, { type: type, params: params, location: location_1 });
                            if (type === interfaces_1.MatchType.ERROR) {
                                _this._outletContextMap.set(exports.errorOutlet, { type: interfaces_1.MatchType.PARTIAL, params: params, location: location_1 });
                            }
                        }
                        catchRejection(_this, context, path, handler({ context: context, params: params }));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return true;
                var e_2, _b;
            });
            // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.
            if (!dispatched || redirect !== undefined) {
                this._currentSelection = [];
            }
            if (!dispatched) {
                this._outletContextMap.set(exports.errorOutlet, {
                    type: interfaces_1.MatchType.PARTIAL,
                    params: {},
                    location: this._history ? this._history.current : ''
                });
                if (this._fallback) {
                    catchRejection(this, context, path, this._fallback({ context: context, params: {} }));
                    return { success: false };
                }
            }
            var result = { success: dispatched };
            if (redirect !== undefined) {
                result.redirect = redirect;
            }
            return result;
        };
        Router.prototype.dispatch = function (context, path) {
            var _this = this;
            var canceled = false;
            var cancel = function () {
                canceled = true;
            };
            var deferrals = [];
            this._currentParams = {};
            this._outletContextMap.clear();
            this.emit({
                context: context,
                cancel: cancel,
                defer: function () {
                    var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;
                    deferrals.push(promise);
                    return { cancel: cancel, resume: resume };
                },
                path: path,
                target: this,
                type: 'navstart'
            });
            // Synchronous cancellation.
            if (canceled) {
                return Task_1.default.resolve({ success: false });
            }
            return new Task_1.default(function (resolve, reject) {
                // *Always* start dispatching in a future turn, even if there were no deferrals.
                Promise_1.default.all(deferrals).then(function () {
                    return _this._dispatch(context, path, canceled, false);
                }, function () {
                    return { success: false };
                }).then(resolve, function (error) {
                    reportError(_this, context, path, error);
                    reject(error);
                });
            }, cancel);
        };
        Router.prototype.link = function (routeOrOutlet, params) {
            var _this = this;
            if (params === void 0) { params = {}; }
            var route;
            if (typeof routeOrOutlet === 'string') {
                var item = this._outletRouteMap.get(routeOrOutlet);
                if (item) {
                    route = item;
                }
                else {
                    throw new Error("No outlet " + routeOrOutlet + " has been registered");
                }
            }
            else {
                route = routeOrOutlet;
            }
            var hierarchy = [route];
            for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {
                hierarchy.unshift(parent_1);
            }
            if (!array_1.includes(this._routes, hierarchy[0])) {
                throw new Error('Cannot generate link for route that is not in the hierarchy');
            }
            var addLeadingSlash = hierarchy[0].path.leadingSlash;
            var addTrailingSlash = false;
            var segments = [];
            var searchParams = new UrlSearchParams_1.default();
            hierarchy
                .map(function (route, index) {
                var path = route.path;
                var currentPathValues;
                var currentSearchParams;
                var selection = _this._currentSelection[index];
                if (selection && selection.route === route) {
                    currentPathValues = selection.rawPathValues;
                    currentSearchParams = selection.rawSearchParams;
                }
                return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path, route: route };
            })
                .forEach(function (_a) {
                var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path, route = _a.route;
                var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;
                addTrailingSlash = trailingSlash;
                var namedOffset = 0;
                try {
                    for (var expectedSegments_1 = tslib_1.__values(expectedSegments), expectedSegments_1_1 = expectedSegments_1.next(); !expectedSegments_1_1.done; expectedSegments_1_1 = expectedSegments_1.next()) {
                        var segment = expectedSegments_1_1.value;
                        if (path_1.isNamedSegment(segment)) {
                            var value = params[segment.name];
                            if (typeof value === 'string') {
                                segments.push(value);
                            }
                            else if (Array.isArray(value)) {
                                if (value.length === 1) {
                                    segments.push(value[0]);
                                }
                                else {
                                    throw new TypeError("Cannot generate link, multiple values for parameter '" + segment.name + "'");
                                }
                            }
                            else if (currentPathValues) {
                                segments.push(currentPathValues[namedOffset]);
                            }
                            else if (route.defaultParams[segment.name]) {
                                segments.push(route.defaultParams[segment.name]);
                            }
                            else {
                                throw new Error("Cannot generate link, missing parameter '" + segment.name + "'");
                            }
                            namedOffset++;
                        }
                        else {
                            segments.push(segment.literal);
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (expectedSegments_1_1 && !expectedSegments_1_1.done && (_b = expectedSegments_1.return)) _b.call(expectedSegments_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                try {
                    for (var searchParameters_1 = tslib_1.__values(searchParameters), searchParameters_1_1 = searchParameters_1.next(); !searchParameters_1_1.done; searchParameters_1_1 = searchParameters_1.next()) {
                        var key = searchParameters_1_1.value;
                        // Don't repeat the search parameter if a previous route in the hierarchy has already appended
                        // it.
                        if (searchParams.has(key)) {
                            continue;
                        }
                        var value = params[key] || _this._defaultParams[key];
                        if (typeof value === 'string') {
                            searchParams.append(key, value);
                        }
                        else if (Array.isArray(value)) {
                            try {
                                for (var value_1 = tslib_1.__values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                                    var item = value_1_1.value;
                                    searchParams.append(key, item);
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (value_1_1 && !value_1_1.done && (_c = value_1.return)) _c.call(value_1);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                        }
                        else if (currentSearchParams) {
                            try {
                                for (var _d = tslib_1.__values(currentSearchParams[key]), _e = _d.next(); !_e.done; _e = _d.next()) {
                                    var item = _e.value;
                                    searchParams.append(key, item);
                                }
                            }
                            catch (e_5_1) { e_5 = { error: e_5_1 }; }
                            finally {
                                try {
                                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                                }
                                finally { if (e_5) throw e_5.error; }
                            }
                        }
                        else {
                            throw new Error("Cannot generate link, missing search parameter '" + key + "'");
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (searchParameters_1_1 && !searchParameters_1_1.done && (_g = searchParameters_1.return)) _g.call(searchParameters_1);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                var e_3, _b, e_6, _g, e_4, _c, e_5, _f;
            });
            var pathname = segments.join('/');
            if (addLeadingSlash) {
                pathname = '/' + pathname;
            }
            if (addTrailingSlash) {
                pathname += '/';
            }
            if (this._history) {
                pathname = this._history.prefix(pathname);
            }
            var search = searchParams.toString();
            var path = search ? pathname + "?" + search : pathname;
            return path;
        };
        Router.prototype.replacePath = function (path) {
            if (!this._history) {
                throw new Error('Cannot replace path, router was created without a history manager');
            }
            this._history.replace(path);
        };
        Router.prototype.setPath = function (path) {
            if (!this._history) {
                throw new Error('Cannot set path, router was created without a history manager');
            }
            this._history.set(path);
        };
        Router.prototype.hasOutlet = function (outletId) {
            return this._outletContextMap.has(outletId);
        };
        Router.prototype.getOutlet = function (outletId) {
            var outletIds = Array.isArray(outletId) ? outletId : [outletId];
            var matchingOutlet = undefined;
            var matchingParams = {};
            var matchingLocation = '';
            for (var i = 0; i < outletIds.length; i++) {
                var outletContext = this._outletContextMap.get(outletIds[i]);
                if (outletContext) {
                    var params = outletContext.params, location_2 = outletContext.location;
                    matchingParams = tslib_1.__assign({}, matchingParams, params);
                    if (!matchingOutlet || matchingLocation.indexOf(location_2) === -1) {
                        matchingLocation = location_2;
                        matchingOutlet = tslib_1.__assign({}, outletContext, { params: matchingParams });
                    }
                }
            }
            return matchingOutlet;
        };
        Router.prototype.getCurrentParams = function () {
            return this._currentParams;
        };
        Router.prototype.start = function (startOptions) {
            var _this = this;
            if (startOptions === void 0) { startOptions = { dispatchCurrent: true }; }
            var dispatchCurrent = startOptions.dispatchCurrent;
            if (this._started) {
                throw new Error('start can only be called once');
            }
            this._started = true;
            if (!this._history) {
                return {
                    pause: function () {
                    },
                    resume: function () {
                    },
                    destroy: function () {
                    }
                };
            }
            var lastDispatch;
            var redirectCount = 0;
            var redirecting = false;
            var dispatch = function (path) {
                if (lastDispatch) {
                    lastDispatch.cancel();
                }
                // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows
                // a route's exec / fallback / index handler to change the history, setting off a new flurry of
                // redirects, without being encumbered by the number of redirects that led to that route being selected.
                if (!redirecting) {
                    redirectCount = 0;
                }
                // Signal to dispatch() that it was called from here.
                _this._dispatchFromStart = true;
                var context = _this._contextFactory();
                lastDispatch = _this.dispatch(context, path).then(function (dispatchResult) {
                    var _a = dispatchResult || { success: false }, success = _a.success, _b = _a.redirect, redirect = _b === void 0 ? undefined : _b;
                    if (success && redirect !== undefined) {
                        redirectCount++;
                        if (redirectCount > 20) {
                            var error = new Error('More than 20 redirects, giving up');
                            reportError(_this, context, path, error);
                            throw error;
                        }
                        redirecting = true;
                        // The history manager MUST emit the change event synchronously.
                        _this._history.replace(redirect);
                        redirecting = false;
                    }
                    return dispatchResult;
                });
                return lastDispatch;
            };
            var listener = on_1.pausable(this._history, 'change', function (event) {
                dispatch(event.value);
            });
            this.own(listener);
            if (dispatchCurrent) {
                var context = this._contextFactory();
                var _a = this._dispatch(context, this._history.current), success = _a.success, _b = _a.redirect, redirect = _b === void 0 ? undefined : _b;
                if (success && redirect) {
                    redirecting = true;
                    this._history.replace(redirect);
                    redirecting = false;
                }
                else if (!success && this._defaultRoute) {
                    var normalizedPath = this._history.normalizePath(this.link(this._defaultRoute));
                    this._dispatch(context, normalizedPath);
                }
            }
            return listener;
        };
        return Router;
    }(Evented_1.default));
    exports.Router = Router;
    exports.default = Router;
});
//# sourceMappingURL=Router.js.map